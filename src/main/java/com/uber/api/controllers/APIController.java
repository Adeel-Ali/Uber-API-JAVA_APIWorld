/*
 * UberAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 09/13/2016
 */
package com.uber.api.controllers;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import com.uber.api.*;
import com.uber.api.models.*;
import com.uber.api.exceptions.*;
import com.uber.api.http.client.HttpClient;
import com.uber.api.http.client.HttpContext;
import com.uber.api.http.request.HttpRequest;
import com.uber.api.http.response.HttpResponse;
import com.uber.api.http.response.HttpStringResponse;
import com.uber.api.http.client.APICallBack;
import com.uber.api.controllers.syncwrapper.APICallBackCatcher;

public class APIController extends BaseController {    
    //private static variables for the singleton pattern
    private static Object syncObject = new Object();
    private static APIController instance = null;

    /**
     * Singleton pattern implementation 
     * @return The singleton instance of the APIController class 
     */
    public static APIController getInstance() {
        synchronized (syncObject) {
            if (null == instance) {
                instance = new APIController();
            }
        }
        return instance;
    }

    /**
     * The Promotions endpoint returns information about the promotion that will be available to a new user based on their activity's location. These promotions do not apply for existing users.
     * @param    GetPromotionsInput    Object containing request parameters
     * @return    Returns the PromotionsResponse response from the API call 
     */
    public PromotionsResponse getPromotions(
                final GetPromotionsInput input
    ) throws Throwable {
        APICallBackCatcher<PromotionsResponse> callback = new APICallBackCatcher<PromotionsResponse>();
        getPromotionsAsync(input, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The Promotions endpoint returns information about the promotion that will be available to a new user based on their activity's location. These promotions do not apply for existing users.
     * @param    GetPromotionsInput    Object containing request parameters
     * @return    Returns the void response from the API call 
     */
    public void getPromotionsAsync(
                final GetPromotionsInput input,
                final APICallBack<PromotionsResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/promotions");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4757861463700048452L;
            {
                    put( "end_latitude", input.getEndLatitude() );
                    put( "end_longitude", input.getEndLongitude() );
                    put( "start_latitude", input.getStartLatitude() );
                    put( "start_longitude", input.getStartLongitude() );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4952672659870129418L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _context);

                            else if (_responseCode == 409)
                                throw new APIException("A conflict needs to be resolved before the request can be made.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            else if (_responseCode == 222)
                                throw new APIException("bac", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PromotionsResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PromotionsResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * The Request endpoint allows a ride to be requested on behalf of an Uber user given their desired product, start, and end locations. Please review the Sandbox documentation on how to develop and test against these endpoints without making real-world Requests and being charged.
     * @param    body    Required parameter: Example: 
     * @return    Returns the Request response from the API call 
     */
    public Request createRequest(
                final RequestBody body
    ) throws Throwable {
        APICallBackCatcher<Request> callback = new APICallBackCatcher<Request>();
        createRequestAsync(body, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The Request endpoint allows a ride to be requested on behalf of an Uber user given their desired product, start, and end locations. Please review the Sandbox documentation on how to develop and test against these endpoints without making real-world Requests and being charged.
     * @param    body    Required parameter: Example: 
     * @return    Returns the void response from the API call 
     */
    public void createRequestAsync(
                final RequestBody body,
                final APICallBack<Request> callBack
    ) throws JsonProcessingException {
        //validating required parameters
        if (null == body)
            throw new NullPointerException("The parameter \"body\" is a required parameter and cannot be null.");

        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/requests");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5128225022343608588L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(body));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json", _context);

                            else if (_responseCode == 409)
                                throw new APIException("A conflict needs to be resolved before the request can be made.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            Request _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<Request>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Cancel an ongoing Request on behalf of a rider.
     * @param    requestId    Required parameter: Unique identifier representing a Request.
     * @return    Returns the void response from the API call 
     */
    public void deleteRequestCancel(
                final String requestId
    ) throws Throwable {
        APICallBackCatcher<Object> callback = new APICallBackCatcher<Object>();
        deleteRequestCancelAsync(requestId, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        callback.getResult();
    }

    /**
     * Cancel an ongoing Request on behalf of a rider.
     * @param    requestId    Required parameter: Unique identifier representing a Request.
     * @return    Returns the void response from the API call 
     */
    public void deleteRequestCancelAsync(
                final String requestId,
                final APICallBack<Object> callBack
    ) {
        //validating required parameters
        if (null == requestId)
            throw new NullPointerException("The parameter \"requestId\" is a required parameter and cannot be null.");

        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/requests/{request_id}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5339521346994033858L;
            {
                    put( "request_id", requestId );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5586884791163722933L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().delete(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _context);

                            else if (_responseCode == 409)
                                throw new APIException("A conflict needs to be resolved before the request can be made", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //let the caller know of the success
                            callBack.onSuccess(_context, _context);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get a map with a visual representation of a Request.
     * @param    requestId    Required parameter: Unique identifier representing a Request.
     * @return    Returns the RequestMapResponse response from the API call 
     */
    public RequestMapResponse getRequestMap(
                final String requestId
    ) throws Throwable {
        APICallBackCatcher<RequestMapResponse> callback = new APICallBackCatcher<RequestMapResponse>();
        getRequestMapAsync(requestId, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get a map with a visual representation of a Request.
     * @param    requestId    Required parameter: Unique identifier representing a Request.
     * @return    Returns the void response from the API call 
     */
    public void getRequestMapAsync(
                final String requestId,
                final APICallBack<RequestMapResponse> callBack
    ) {
        //validating required parameters
        if (null == requestId)
            throw new NullPointerException("The parameter \"requestId\" is a required parameter and cannot be null.");

        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/requests/{request_id}/map");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4985873224030824758L;
            {
                    put( "request_id", requestId );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5118730632108477702L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _context);

                            else if (_responseCode == 409)
                                throw new APIException("A conflict needs to be resolved before the request can be made.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            RequestMapResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<RequestMapResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.
     * @param    GetPriceEstimatesInput    Object containing request parameters
     * @return    Returns the PriceEstimateCollection response from the API call 
     */
    public PriceEstimateCollection getPriceEstimates(
                final GetPriceEstimatesInput input
    ) throws Throwable {
        APICallBackCatcher<PriceEstimateCollection> callback = new APICallBackCatcher<PriceEstimateCollection>();
        getPriceEstimatesAsync(input, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.
     * @param    GetPriceEstimatesInput    Object containing request parameters
     * @return    Returns the void response from the API call 
     */
    public void getPriceEstimatesAsync(
                final GetPriceEstimatesInput input,
                final APICallBack<PriceEstimateCollection> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/estimates/price");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5161632136524194690L;
            {
                    put( "end_latitude", input.getEndLatitude() );
                    put( "end_longitude", input.getEndLongitude() );
                    put( "start_latitude", input.getStartLatitude() );
                    put( "start_longitude", input.getStartLongitude() );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5571377178900422865L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PriceEstimateCollection _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PriceEstimateCollection>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
     * @param    GetTimeEstimatesInput    Object containing request parameters
     * @return    Returns the TimeEstimateCollection response from the API call 
     */
    public TimeEstimateCollection getTimeEstimates(
                final GetTimeEstimatesInput input
    ) throws Throwable {
        APICallBackCatcher<TimeEstimateCollection> callback = new APICallBackCatcher<TimeEstimateCollection>();
        getTimeEstimatesAsync(input, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
     * @param    GetTimeEstimatesInput    Object containing request parameters
     * @return    Returns the void response from the API call 
     */
    public void getTimeEstimatesAsync(
                final GetTimeEstimatesInput input,
                final APICallBack<TimeEstimateCollection> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/estimates/time");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5169329669263324108L;
            {
                    put( "start_latitude", input.getStartLatitude() );
                    put( "start_longitude", input.getStartLongitude() );
                    put( "customer_uuid", input.getCustomerUuid() );
                    put( "product_id", input.getProductId() );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5661991461454407565L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            TimeEstimateCollection _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<TimeEstimateCollection>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.
     * @param    GetUserActivityV11Input    Object containing request parameters
     * @return    Returns the UserActivity response from the API call 
     */
    public UserActivity getUserActivityV11(
                final GetUserActivityV11Input input
    ) throws Throwable {
        APICallBackCatcher<UserActivity> callback = new APICallBackCatcher<UserActivity>();
        getUserActivityV11Async(input, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.
     * @param    GetUserActivityV11Input    Object containing request parameters
     * @return    Returns the void response from the API call 
     */
    public void getUserActivityV11Async(
                final GetUserActivityV11Input input,
                final APICallBack<UserActivity> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1.1/history");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5111348175338250188L;
            {
                    put( "limit", input.getLimit() );
                    put( "offset", input.getOffset() );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5140723336932030608L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            UserActivity _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<UserActivity>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get product details w.r.t id
     * @param    productId    Required parameter: Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
     * @return    Returns the Product response from the API call 
     */
    public Product getProductDetailByID(
                final String productId
    ) throws Throwable {
        APICallBackCatcher<Product> callback = new APICallBackCatcher<Product>();
        getProductDetailByIDAsync(productId, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get product details w.r.t id
     * @param    productId    Required parameter: Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
     * @return    Returns the void response from the API call 
     */
    public void getProductDetailByIDAsync(
                final String productId,
                final APICallBack<Product> callBack
    ) {
        //validating required parameters
        if (null == productId)
            throw new NullPointerException("The parameter \"productId\" is a required parameter and cannot be null.");

        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/products/{product_id}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4953137299577571374L;
            {
                    put( "product_id", productId );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4614772289725488445L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            Product _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<Product>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get the real time status of an ongoing trip that was created using the Ride Request endpoint.
     * @param    requestId    Required parameter: Example: 
     * @return    Returns the RequestDetailsCollections response from the API call 
     */
    public RequestDetailsCollections getRequestDetails(
                final String requestId
    ) throws Throwable {
        APICallBackCatcher<RequestDetailsCollections> callback = new APICallBackCatcher<RequestDetailsCollections>();
        getRequestDetailsAsync(requestId, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get the real time status of an ongoing trip that was created using the Ride Request endpoint.
     * @param    requestId    Required parameter: Example: 
     * @return    Returns the void response from the API call 
     */
    public void getRequestDetailsAsync(
                final String requestId,
                final APICallBack<RequestDetailsCollections> callBack
    ) {
        //validating required parameters
        if (null == requestId)
            throw new NullPointerException("The parameter \"requestId\" is a required parameter and cannot be null.");

        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/requests/{request_id}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5234529804712778488L;
            {
                    put( "request_id", requestId );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4871472906780379665L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", _context);

                            else if (_responseCode == 409)
                                throw new APIException("A conflict needs to be resolved before the request can be made.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            RequestDetailsCollections _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<RequestDetailsCollections>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
     * @param    GetProductsTypesInput    Object containing request parameters
     * @return    Returns the ProductCollection response from the API call 
     */
    public ProductCollection getProductsTypes(
                final GetProductsTypesInput input
    ) throws Throwable {
        APICallBackCatcher<ProductCollection> callback = new APICallBackCatcher<ProductCollection>();
        getProductsTypesAsync(input, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
     * @param    GetProductsTypesInput    Object containing request parameters
     * @return    Returns the void response from the API call 
     */
    public void getProductsTypesAsync(
                final GetProductsTypesInput input,
                final APICallBack<ProductCollection> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/products");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4950989192745882158L;
            {
                    put( "latitude", input.getLatitude() );
                    put( "longitude", input.getLongitude() );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4911300459875101744L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            ProductCollection _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<ProductCollection>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * The User Profile endpoint returns information about the Uber user that has authorized with the application.
     * @return    Returns the UserProfile response from the API call 
     */
    public UserProfile getUserProfile(
    ) throws Throwable {
        APICallBackCatcher<UserProfile> callback = new APICallBackCatcher<UserProfile>();
        getUserProfileAsync(callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * The User Profile endpoint returns information about the Uber user that has authorized with the application.
     * @return    Returns the void response from the API call 
     */
    public void getUserProfileAsync(
                final APICallBack<UserProfile> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/v1/me");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4863508711250401577L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new APIException("Malformed request.", _context);

                            else if (_responseCode == 401)
                                throw new APIException("Unauthorized the request requires user authentication (not logged in).", _context);

                            else if (_responseCode == 403)
                                throw new APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", _context);

                            else if (_responseCode == 404)
                                throw new APIException("Not found.", _context);

                            else if (_responseCode == 406)
                                throw new APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", _context);

                            else if (_responseCode == 422)
                                throw new APIException("Invalid request. The request body is parse-able however with invalid content.", _context);

                            else if (_responseCode == 429)
                                throw new APIException("Too Many Requests. Rate limited.", _context);

                            else if (_responseCode == 500)
                                throw new APIException("Internal Server Error.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            UserProfile _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<UserProfile>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

}